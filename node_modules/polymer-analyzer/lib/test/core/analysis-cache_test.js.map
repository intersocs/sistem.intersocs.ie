{"version":3,"sources":["test/core/analysis-cache_test.ts"],"names":[],"mappings":"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","file":"analysis-cache_test.js","sourcesContent":["/**\n * @license\n * Copyright (c) 2015 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\nimport {assert} from 'chai';\n\nimport {AnalysisCache} from '../../core/analysis-cache';\nimport {ResolvedUrl} from '../../model/url';\n\nsuite('AnalysisCache', () => {\n  test('it can be constructed', () => {\n    new AnalysisCache();\n  });\n\n  function addFakeDocumentToCache(\n      cache: AnalysisCache, path: string, dependencies: string[]) {\n    const resolvedPath = path as ResolvedUrl;\n    const resolvedDependencies = dependencies as ResolvedUrl[];\n    cache.parsedDocumentPromises.set(\n        resolvedPath, `parsed ${resolvedPath} promise` as any);\n    cache.scannedDocumentPromises.set(\n        resolvedPath, `scanned ${resolvedPath} promise` as any);\n    cache.analyzedDocumentPromises.set(\n        resolvedPath, `analyzed ${resolvedPath} promise` as any);\n    cache.scannedDocuments.set(resolvedPath, `scanned ${resolvedPath}` as any);\n    cache.analyzedDocuments.set(\n        resolvedPath, `analyzed ${resolvedPath}` as any);\n    cache.dependencyGraph.addDocument(resolvedPath, resolvedDependencies);\n  }\n\n  async function assertHasDocument(cache: AnalysisCache, path: string) {\n    const resolvedPath = path as ResolvedUrl;\n    assert.equal(\n        await cache.parsedDocumentPromises.getOrCompute(\n            resolvedPath, null as any) as any,\n        `parsed ${resolvedPath} promise`);\n    assert.equal(\n        await cache.scannedDocumentPromises.getOrCompute(\n            resolvedPath, null as any) as any,\n        `scanned ${resolvedPath} promise`);\n    // caller must assert on cache.analyzedDocumentPromises themselves\n    assert.equal(\n        cache.scannedDocuments.get(resolvedPath) as any,\n        `scanned ${resolvedPath}`);\n    assert.equal(\n        cache.analyzedDocuments.get(resolvedPath) as any,\n        `analyzed ${resolvedPath}`);\n  }\n\n  function assertNotHasDocument(cache: AnalysisCache, p: string) {\n    const path = p as ResolvedUrl;\n    assert.isFalse(cache.parsedDocumentPromises.has(path));\n    assert.isFalse(cache.scannedDocumentPromises.has(path));\n    // caller must assert on cache.analyzedDocumentPromises themselves\n    assert.isFalse(cache.scannedDocuments.has(path));\n    assert.isFalse(cache.analyzedDocuments.has(path));\n  }\n\n  async function assertDocumentScannedButNotResolved(\n      cache: AnalysisCache, p: string) {\n    const path = p as ResolvedUrl;\n    assert.equal(\n        await cache.parsedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `parsed ${path} promise`);\n\n    assert.equal(\n        await cache.scannedDocumentPromises.getOrCompute(\n            path, null as any) as any,\n        `scanned ${path} promise`);\n    assert.equal(cache.scannedDocuments.get(path) as any, `scanned ${path}`);\n    assert.isFalse(cache.analyzedDocuments.has(path));\n    assert.isFalse(cache.analyzedDocumentPromises.has(path));\n  }\n\n  test('it invalidates a path when asked to', async() => {\n    const cache = new AnalysisCache();\n    addFakeDocumentToCache(cache, 'index.html', []);\n    addFakeDocumentToCache(cache, 'unrelated.html', []);\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n    const forkedCache = cache.invalidate(['index.html'] as ResolvedUrl[]);\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    assertNotHasDocument(forkedCache, 'index.html');\n    await assertHasDocument(forkedCache, 'unrelated.html');\n\n    // The promise of unrelated.html's result has been turned into\n    // a Promise.resolve() of its non-promise cache.\n    assert.equal(\n        await forkedCache.analyzedDocumentPromises.getOrCompute(\n            'unrelated.html' as ResolvedUrl, null as any) as any,\n        `analyzed unrelated.html`);\n  });\n\n  test('it invalidates the dependants of a path when asked to', async() => {\n    const cache = new AnalysisCache();\n    // Picture a graph where\n    addFakeDocumentToCache(cache, 'index.html', ['element.html']);\n    addFakeDocumentToCache(cache, 'element.html', ['behavior.html']);\n    addFakeDocumentToCache(cache, 'behavior.html', []);\n    addFakeDocumentToCache(cache, 'unrelated.html', []);\n\n    // We added the documents.\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    await assertHasDocument(cache, 'behavior.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n\n    const forkedCache = cache.invalidate(['behavior.html'] as ResolvedUrl[]);\n    // The original cache is untouched.\n    await assertHasDocument(cache, 'index.html');\n    await assertHasDocument(cache, 'unrelated.html');\n    await assertHasDocument(cache, 'behavior.html');\n    await assertHasDocument(cache, 'unrelated.html');\n\n    // The fork has no trace of behavior.html, and its dependants are scanned\n    // but not resolved. Unrelated documents are still fully cached.\n    assertNotHasDocument(forkedCache, 'behavior.html');\n    await assertDocumentScannedButNotResolved(forkedCache, 'index.html');\n    await assertDocumentScannedButNotResolved(forkedCache, 'element.html');\n    await assertHasDocument(forkedCache, 'unrelated.html');\n  });\n});\n"]}